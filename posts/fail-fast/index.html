<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="shortcut icon" href="https://aerb.github.io/favicon.ico">

    <link rel="stylesheet" href="/css/style.min.css">

    <title>Software Circuit Breakers</title>
</head>
<body><header id="banner">
    <h2><a href="https://aerb.github.io/">computer says no</a></h2>
    <nav>
        <ul>

        </ul>
    </nav>
</header>
<main id="content">
<article>
    <header id="post-header">
        <h1>Software Circuit Breakers</h1><time>February 14, 2021</time></header><p>I don&rsquo;t think this is a controversial opinion, but it&rsquo;s the one I find myself repeating the most often, so I&rsquo;m putting it here for reference.</p>
<p>One the most common anti-patterns in software development is something that looks like this:</p>
<pre><code>val tribble = getTribble(id)
if (tribble == null)
  return
</code></pre><p>In some contexts this type code is fine, but in most it is not. It is a silent failure, which is the worst type of failure!</p>
<h1 id="what-is-null">What is <code>null</code>?</h1>
<p>First what is a <code>null</code> Tribble? While Kotlin certainly supports richer ways of communicating errors, it comes from the tradition of Java and C, so usually uses <code>null</code> to represent the absence of a thing. From the perspective of <code>getTribble()</code> this is an error, since it&rsquo;s only purpose is to return a tribble. <code>tribble == null</code> is essentially short for <code>ERROR_NO_TRIBBLE_FOUND</code>.</p>
<h1 id="types-of-errors">Types of Errors</h1>
<p>When thinking about error handling I find it useful to split errors into two categories: recoverable, and non-recoverable <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. There’s “Hey something came up, but we kinda foresaw this, so here’s how we’re going to make it right”, and then there’s “The server got hit by lightning”. Where exactly to draw this line is debatable but for my purposes here, I consider non-recoverable means “There is no sensible way to proceed at this time” (non-recoverable does not mean non-retryable)</p>
<p>Depending on context if <code>ERROR_NO_TRIBBLE_FOUND</code> is considered recoverable then we might be ok here. The function returns <code>ERROR_NO_TRIBBLE_FOUND</code> and the caller says “Oh, ok. <code>makeNewTribble()</code>”.  If the error is non-recoverable however the code above can be very insidious. Maybe a Tribble <em>has</em> to exist in this state, and its absence suggests something very unexpected. We may have arrived here because of programming error, maybe network error, or maybe the server was hit by lightning.</p>
<h1 id="the-worst-type-of-bug">The Worst Type of Bug</h1>
<p>Now consider the example in this context:</p>
<pre><code>fun assignTribbleToShip(id: String) {
  val tribble = getTribble(id)
  if (tribble == null)
    return
  getShip().tribbles += tribble
}
</code></pre><p>This is where things start to get ugly. We called <code>assignTribbleToShip</code>, but the error <code>ERROR_NO_TRIBBLE_FOUND</code>, has been ignored. We think the tribble was assigned to our ship, but that is not true. Let&rsquo;s add more context:</p>
<pre><code>fun assignTribbleApi(id: String): HttpResponse {
  assignTribbleToShip(id)
  emitTribbleAssignedEvent(id)
  incrementGlobalTribbleCount()
  return OK
}
</code></pre><p>Now things are starting to get really ugly. Because we ignored the error, other parts of the system are starting to get into an incorrect state. Our global tribble count is off - we&rsquo;ve also emitted a <code>TibbleAssignedEvent</code> which will potentially trigger other side effects. What has effectively happened is we’re now starting to corrupt the data in our system. It is no longer true, and the more this failure happens the more wrong our system will get.</p>
<p>This is one of the worst bugs we can introduce as programmers. Worse than our server 500’ing, worse than our app crashing. We no longer know what is true, and neither does our customer. We can probably only recover from this via manual intervention.</p>
<h1 id="a-better-way">A Better Way</h1>
<p>So a better approach? It’s actually pretty easy:</p>
<pre><code>getTribble(id)!!
</code></pre><p>or better yet:</p>
<pre><code>getTribble(id) ?: throw NotFound(“No tribble $id”)
</code></pre><p>Throw <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>. We fail immediately, at the first sign of trouble. We simply see <code>ERROR_NO_TRIBBLE_FOUND</code> error, and declare &ldquo;This is unrecoverable!&rdquo;. Throw up our arms and say &ldquo;I give up!&rdquo;.</p>
<p>I was first exposed to this idea in <a href="https://en.wikipedia.org/wiki/The_Art_of_Unix_Programming">&ldquo;The Art of Unix Programming&rdquo;</a>. It is a Rule in <a href="https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html">Unix Philosophy</a> known as:</p>
<blockquote>
<p>Rule of Repair: When you must fail, fail noisily and as soon as possible.</p>
</blockquote>
<p>The idea is basic: If something is fundamentally wrong, fail immediately and make a bunch of noise. You won&rsquo;t be silently corrupting your system, and hopefully a human notices something is wrong and comes to help.</p>
<p>A good physical metaphor for this is a circuit breaker. If the amount of current entering the system is more than can be handled, immediately fail off. Is it annoying? Yes, but it stopped our system from continuing, possibly causing more damage.</p>
<p>This is a concept that is also at the heart of the <a href="https://www.erlang.org/">Erlang Programming Language</a>, and the <a href="https://en.wikipedia.org/wiki/Actor_model">Actor Model</a>. Erlang has a pretty good track record for high availability, it runs a lot of the world&rsquo;s telecommunication networks! When was the last time you can remember phone lines being down?</p>
<h1 id="eating-your-cake-too">Eating your Cake too</h1>
<p>The best part of this pattern is when combined with higher level &ldquo;supervisor&rdquo; functions you can still immediately fail, but potentially recover. Naturally if your program is in a weird state and throws an error the best strategy is to retry. Depending on the error sometimes this will work, sometimes not, but it gives the system a chance to self heal if it can.</p>
<p>The supervisor mechanism is another page from Erlang and Actors, but it&rsquo;s an idea that has naturally taken root everywhere you look. Your server framework may have an unhandled exception handler that triggers retry, your clients may retry on 500, if your application process crashes there is probably a daemon manager that will retry the process. In the end if all those things don&rsquo;t work there&rsquo;s a good chance a human will come along and retry.</p>
<h1 id="why-we-do-the-wrong-thing-and-how-to-stop">Why we do the Wrong Thing, and How to Stop</h1>
<p>I believe there are a couple reasons behind the &ldquo;<code>if null return</code>&rdquo; anti-pattern and all of them are very human.</p>
<p>One reason is it can be embarrassing to cause a bunch of noisy errors in an application if you are working on a team. Worse yet, you might be causing an issue that blocks someone else on your team. Maybe they planned to perform testing on staging but now staging is unusable.</p>
<p>Another reason might be you don&rsquo;t know everything about your system. Maybe you’re not sure of the guarantees of <code>getTribble</code> because it’s legacy code and undocumented, and you <em>just</em> want to be sure you’re not going to cause problems in production.</p>
<p>These are completely valid concerns. The good news is you can avoid them with &hellip;</p>
<h1 id="feature-flags">Feature Flags</h1>
<p>Feature Flags are amazing. You can make your changes behind a flag, fail as pedantically / loudly as you want, and immediately revert if you are starting to see serious problems. This allows your application to be strict and error tolerant, but revertible if that strictness is causing blocking problems.</p>
<p>I’ve used <a href="https://launchdarkly.com/">LaunchDarkly</a> and have no complaints. If you don&rsquo;t have a budget, you can probably roll your own without much work. You basically just want a remote way to enable / disable code paths. <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></p>
<h1 id="final-thoughts">Final Thoughts</h1>
<p>Problems tend to beget more problems. Ignoring signs that something is wrong typically allows those problems to take root and become worse. In programming languages that support it, you should feel comfortable to <code>throw</code> and <code>throw</code> often. <code>Exception</code>s are your friend, they tell you when something is wrong before more serious problems start to manifest.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Rust makes this exact distinction in its <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">error handling</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>There&rsquo;s a lot of debate about whether exceptions are net good or bad. There are good points on both sides, but use-cases like this are when I find them very valuable. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p><em>Please</em> cleanup old flags once you&rsquo;ve verified there are no problems. <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
</article>

        </main><footer id="footer">

</footer>
</body>
</html>
